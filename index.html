<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TOT Card Order</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Tears of Themis - Debate Card Sequence Arranger</h1>
            <p>Website Created by <a href="https://www.hoyolab.com/accountCenter/postList?id=466404617" target="_blank">@Yakitori_UwU</a></p>
            <p>Thank you to <a href="https://www.hoyolab.com/accountCenter?id=363999098" target="_blank">@dodogitu</a> for sharing this method (Their post here: <a href="https://www.hoyolab.com/article/31954175" target="_blank">How to Rearrange Card Sequence | Video Tutorial</a>).</p>
        </div>

        <div class="instructions">
            <details open>
                <summary>How to use this website</summary>
                <ol>
                    <li>If it's your first time using this website, please first go to the <strong>"Create/Edit Your Card Collection"</strong> tab.
                        <ul>
                            <li>Add all the cards that you have/typically use in your deck.</li>
                            <li>Save your card collection, which will download a `card_collection.txt` file to your computer.</li>
                        </ul>
                    </li>
                    <li>Every time you use this website:
                        <ul>
                            <li>Use the <strong>"(1) Load Your Card Collection" tab.</strong></li>
                            <li>Click on the <strong>"(2) Track and Modify the Card Order"</strong> tab and follow the 4-step process.</li>
                        </ul>
                    </li>
                </ol>
            </details>
        </div>

        <div class="tabs">
            <button class="tab-button active" onclick="showTab('collection')">(1) Load Your Card Collection</button>
            <button class="tab-button" onclick="showTab('welcome')">(2) Track and Modify Card Order</button>
            <button class="tab-button" onclick="showTab('create')">Create/Edit Your Card Collection</button>
        </div>

        <!-- Welcome Tab -->
        <div id="welcome" class="tab-content">
            <div class="welcome-tab">
                <h2>Track and Modify Card Order</h2>
                <p>Follow the 4-step process below, which allow you to control which card would appear in the first 15 turns.</p>
                
                <!-- 1. Collection Status -->
                <div class="collection-status" id="collectionStatus" style="margin-bottom: 20px; padding: 15px; border-radius: 8px; background-color: #f8f9fa; border: 1px solid #dee2e6;">
                    <strong>Collection Status:</strong> <span id="statusText">No collection loaded</span>
                    <br><small>Go to the "(1) Load Your Card Collection" tab to load your card collection file (.txt)</small>
                </div>
                
                <!-- <div class="grid-controls" style="margin-bottom: 20px; text-align: center;">
                    <button class="btn btn-primary" onclick="exportGridConfig()" style="margin-right: 10px;">Save Order Tracking Progress</button>
                    <button class="btn btn-secondary" onclick="loadGridConfig()" style="margin-right: 10px;">Load Order Tracking Progress</button> -->
                    <!-- <button class="btn btn-warning" onclick="clearFilterMemory()" title="Clear saved filter preferences">Clear Filter Memory</button> -->
                <!-- </div> -->
                
                <!-- 2. Initial Card Grid -->
                <div class="grid-section">
                    <h3>(Step 1) Write Down Your Deck + Track the Order Cards Appear</h3>
                    <div class="instructions" style="margin: 0 auto; width: 60%; text-align: left; font-size: 1.1rem;">
                    <ol>
                        <li>Recreate your card deck in the grid below. Click on + to select a card at that position.</li>
                        <li>Start the debate. Make sure to use the <strong>manual debate</strong> mode.</li>
                        <li>Use the gray dropdowns to track down the order each card appears (1-15).</li>
                    </ol>
                    </div>
                    <br>
                    <div class="order-counter" style="margin: 0 auto; width: 60%; text-align: center; margin-bottom: 15px; padding: 10px; background-color: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6;">
                        <span style="font-weight: 600; color: #495057; font-size: 1.1rem;">Number of Cards Tracked: </span>
                        <span id="orderProgressCounter" style="font-weight: 700; color: #28a745; font-size: 1.2rem;">0</span>
                        <span style="font-weight: 600; color: #495057; font-size: 1.1rem;"> / 15</span>
                    </div>
                    <div id="orderWarning" style="display: none; margin: 0 auto; width: 60%; text-align: center; margin-bottom: 15px; padding: 15px; background-color: #fff3cd; border-radius: 8px; border: 1px solid #ffeaa7; color: #856404; font-size: 0.95rem; line-height: 1.4;">
                        <!-- Warning text will be populated by JavaScript -->
                    </div>
                    <div class="card-grid" id="initialCardGrid">
                        <!-- 3x5 grid will be generated by JavaScript -->
                    </div>
                </div>
                
                <!-- 2.5 Enemy Wave Tracker -->
                <div class="grid-section" id="enemyWaveSection">
                    <h3>(Step 2) Optionally, Track the Enemy Wave</h3>
                    <div class="instructions" style="margin: 0 auto; width: 60%; text-align: left; font-size: 1.1rem;">
                    <p>This helps you plan out what attributes your deck needs to have.</p>
                    <ul>
                        <li>Select the number of waves and write down the enemy attributes per wave.</li>
                        <li>Alternatively, visit the <a href="https://tot.wiki/" target="_blank">TOT Wiki</a> to check the enemy waves and attributes.</li>
                    </ul>
                    </div>
                    <br>
                    <div class="wave-controls" style="margin-bottom: 12px; font-size: 1.1rem;">
                        <label for="waveCountSelect" style="margin-right: 8px; font-weight: 600; color: #495057; font-size: 1.1rem;">Number of Waves:</label>
                        <select id="waveCountSelect" class="grid-dropdown" style="max-width: 160px; font-size: 1.1rem;">
                            <option value="2">2</option>
                            <option value="3">3</option>
                        </select>
                    </div>
                    <div class="enemy-wave-tracker" id="enemyWaveTracker" >
                        <!-- Enemy waves grid will be generated by JavaScript -->
                    </div>
                </div>

                <!-- 3. Attribute Planner -->
                <div class="grid-section">
                    <h3>(Step 3) Plan Out What Attribute (Then What Card) to Appear in Order</h3>
                    <div class="instructions" style="margin: 0 auto; width: 60%; text-align: left; font-size: 1.1rem;">
                    <ol>
                        <li>Decide what attribute to appear in order. Take into account how many cards you need to beat an enemy attribute.</li>
                        <li>Select the card you want to appear in that position. It will automatically update the new card deck below.</li>
                        <ul>
                            <li>Tips: You do not have to select all the attributes. Most importantly, you need to decide what card to appear in other.</li>
                        </ul>
                    </ol>
                    </div>
                    <div class="attribute-planner" id="attributePlanner">
                        <!-- 1x15 grid will be generated by JavaScript -->
                    </div>
                </div>
                
                <!-- 4. New Card Grid -->
                <div class="grid-section">
                    <h3>(Step 4) Copy the New Card Deck and Use It for Debate!</h3>
                    <div class="instructions" style="margin: 0 auto; width: 60%; text-align: left; font-size: 1.1rem;">
                    <ul>
                        <li>Copy the new card deck into your game.</li>
                        <li>Tips: You just need to click on the cards in game following the order from left to right, top to bottom.</li>
                    </ul>
                    </div>
                    <br>
                    <div class="card-grid" id="newCardGrid">
                        <!-- 3x5 grid will be generated by JavaScript -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Card Collection Tab -->
        <div id="collection" class="tab-content active">
            <h2>Load Your Card Collection</h2>
            <p>If you haven't created your card collection yet, please go to the <strong>"Create/Edit Your Card Collection"</strong> tab.</p>
            <br>
            
            <div class="load-section">
                <h3>Load Your Card Collection</h3>
                <p style="font-size: 0.9rem; color: #666; margin-bottom: 15px;">
                    Supported format: text files (.txt) with one card name per line
                </p>
                <div class="file-input-wrapper">
                    <input type="file" id="collectionFile" class="file-input" accept=".txt">
                    <button class="btn btn-primary" onclick="loadCollection()">Load Collection</button>
                </div>
            </div>

            <div class="filters-section">
                <h3>Current Card Collection</h3>
                <div class="filters-row">
                    <div class="filter-group">
                        <label for="attributeFilter">Attribute:</label>
                        <select id="attributeFilter" onchange="filterCards()">
                            <option value="">All Attributes</option>
                            <option value="Logic">🔹 Logic</option>
                            <option value="Empathy">❤️ Empathy</option>
                            <option value="Intuition">🌲 Intuition</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="searchFilter">Search by Name:</label>
                        <input type="text" id="searchFilter" placeholder="Enter card name..." oninput="filterCards()">
                    </div>
                </div>
            </div>

            <div id="collectionCards" class="cards-grid">
                <div class="no-cards-message">No cards loaded. Please load a collection file first.</div>
            </div>
        </div>

        <!-- Create Card Collection Tab -->
        <div id="create" class="tab-content">
            <h2>Create/Edit Your Card Collection</h2>
            
            <div class="create-collection-section">
                <h3>Your Selected Cards</h3>
                <div id="selectedCards" class="cards-grid">
                    <div class="no-cards-message">No cards selected yet. Click the + button on cards to add them to your collection.</div>
                </div>
                <button class="btn btn-success" onclick="downloadCollection()" style="margin-top: 20px;">Download Collection</button>
                <!-- <button class="btn btn-info" onclick="downloadDetailedCollection()" style="margin-top: 20px; margin-left: 10px;">Download Detailed List</button> -->
                <!-- <button class="btn btn-warning" onclick="debugCardDatabase()" style="margin-top: 20px; margin-left: 10px;">Debug Database</button> -->
            </div>

            <div class="filters-section">
                <h3>Search Cards</h3>
                <p>Tips: In game, select "Story" instead of "Debate" to see the card name. Use the search bar to search by card name.</p>
                <br>
                <div class="filters-row">
                    <div class="filter-group">
                        <label for="createAttributeFilter">Attribute:</label>
                        <select id="createAttributeFilter" onchange="filterCreateCards()">
                            <option value="">All Attributes</option>
                            <option value="Logic">🔹 Logic</option>
                            <option value="Empathy">❤️ Empathy</option>
                            <option value="Intuition">🌲 Intuition</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="createSearchFilter">Search by Name:</label>
                        <input type="text" id="createSearchFilter" placeholder="Enter card name..." oninput="filterCreateCards()">
                    </div>
                </div>
            </div>

            <div id="createCards" class="cards-grid">
                <div class="no-cards-message">Loading cards from database...</div>
            </div>
        </div>

        <div class="footer">
            <p>Website Created by <a href="https://www.hoyolab.com/accountCenter/postList?id=466404617" target="_blank">@Yakitori_UwU</a></p>
            <p>Thank you to <a href="https://www.hoyolab.com/accountCenter?id=363999098" target="_blank">@dodogitu</a> for sharing this method (Their post here: <a href="https://www.hoyolab.com/article/31954175" target="_blank">How to Rearrange Card Sequence | Video Tutorial</a>).</p>
        </div>
    </div>

    <!-- Card Selection Modal -->
    <div id="cardModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modalTitle">Select a Card</h3>
                <span class="close" onclick="closeModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="modal-filters">
                    <div class="filter-group">
                        <label for="modalAttributeFilter">Attribute:</label>
                        <select id="modalAttributeFilter" onchange="filterModalCards()">
                            <option value="">All Attributes</option>
                            <option value="Logic">🔹 Logic</option>
                            <option value="Empathy">❤️ Empathy</option>
                            <option value="Intuition">🌲 Intuition</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="modalSearchFilter">Search by Name:</label>
                        <input type="text" id="modalSearchFilter" placeholder="Enter card name..." oninput="filterModalCards()">
                    </div>
                    <div class="filter-memory-indicator" id="filterMemoryIndicator" style="display: none; margin-left: 15px; padding: 5px 10px; background-color: #e8f5e8; border-radius: 4px; font-size: 0.8rem; color: #2e7d32;">
                        <span>💾 Filters restored</span>
                    </div>
                </div>
                <div class="filter-status" id="modalFilterStatus" style="margin: 10px 0; padding: 8px; background-color: #f8f9fa; border-radius: 4px; font-size: 0.9rem; color: #666;">
                    <strong>Filter Status:</strong> <span id="filterStatusText">Showing all available cards</span>
                </div>
                <div id="modalCards" class="modal-cards-grid">
                    <!-- Cards will be loaded here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Collection Preview Modal -->
    <div id="collectionPreviewModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Preview Card Collection Download</h3>
                <span class="close" onclick="closeCollectionPreviewModal()">&times;</span>
            </div>
            <div class="modal-body">
                <p>For full transparency, the website will download a list of card names (shown below) as a .txt file to your computer when you click "Download Collection".</p>
                <p>If you do not want to directly download the file, you can manually copy and paste them into a .txt file yourself!</p>
                <div class="collection-preview">
                    <div class="preview-header">
                        <strong>Selected Cards (${selectedCards.length}):</strong>
                    </div>
                    <div class="preview-content" id="collectionPreviewContent">
                        <!-- Preview content will be loaded here -->
                    </div>
                </div>
                <div class="preview-actions">
                    <button class="btn btn-success" onclick="confirmDownload()">Download Collection</button>
                    <button class="btn btn-secondary" onclick="closeCollectionPreviewModal()">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let allCards = [];
        let userCollection = [];
        let selectedCards = [];
        let initialGrid = Array(15).fill(null); // Initial card grid
        let newGrid = Array(15).fill(null); // New card grid
        let userGridNumbers = Array(15).fill(0); // Store number values (0-15) for initial grid, default to 0
        let userGridAttributes = Array(15).fill(''); // Store attribute values for attribute planner
        let currentGridCell = null; // Track which cell is being edited
        let currentGridId = null; // Track which grid is being edited
        let gridsInitialized = false; // Track if grids have been initialized
        let waveCount = 2; // Enemy wave tracker: number of waves (2 or 3)
        let enemyWaves = []; // Array of columns; first n-1 columns have 3 rows, last column has 1 row
        
        // Modal filter memory: remembers attribute and search filter selections for each grid
        // so users don't have to re-select their filters every time they open the modal
        let modalFilterMemory = {}; // Store filter values for each grid to remember selections

        // Helper function to get display name for attributes
        function getAttributeDisplayName(attribute) {
            if (!attribute) return 'None';
            const displayNames = {
                'Logic': '🔹 Logic',
                'Empathy': '❤️ Empathy',
                'Intuition': '🌲 Intuition'
            };
            return displayNames[attribute] || attribute;
        }

        // Initialize collection status when page loads
        document.addEventListener('DOMContentLoaded', function() {
            updateCollectionStatus();
            // Initialize grids on first load
            if (!gridsInitialized) {
                initializeGrids();
            }
        });

        // Tab functionality
        function showTab(tabName) {
            // Hide all tabs
            const tabs = document.querySelectorAll('.tab-content');
            tabs.forEach(tab => tab.classList.remove('active'));
            
            // Remove active class from all buttons
            const buttons = document.querySelectorAll('.tab-button');
            buttons.forEach(btn => btn.classList.remove('active'));
            
            // Show selected tab
            document.getElementById(tabName).classList.add('active');
            
            // Add active class to clicked button
            event.target.classList.add('active');
            
            // Load cards for create tab if it's the first time
            if (tabName === 'create' && allCards.length === 0) {
                loadAllCards();
            }
            
            // When entering Create/Edit tab, sync selected cards with loaded collection if none selected yet
            if (tabName === 'create') {
                if (selectedCards.length === 0 && userCollection.length > 0) {
                    selectedCards = [...userCollection];
                    displaySelectedCards();
                } else {
                    // Ensure the UI reflects current selection
                    displaySelectedCards();
                }
            }
            
            // Refresh grids if it's the welcome tab (but preserve existing data)
            if (tabName === 'welcome') {
                refreshGrids();
                updateCollectionStatus();
            }
        }

        // Initialize the grids for the new layout
        function initializeGrids() {
            // Initialize default values for dropdowns
            userGridNumbers = Array(15).fill(0); // Default to 0 for all positions
            userGridAttributes = Array(15).fill(''); // Default to empty (none)
            
            createInitialGrid();
            initializeEnemyWaves();
            createEnemyWaveTracker();
            createAttributePlanner();
            createNewGrid();
            
            // Initialize the order progress counter
            updateOrderProgressCounter();
            
            gridsInitialized = true;
        }

        // Refresh grids without resetting data (for tab switching)
        function refreshGrids() {
            // Only initialize if grids haven't been created yet
            if (!gridsInitialized) {
                // First time loading, initialize with defaults
                initializeGrids();
            } else {
                // Refresh existing grids with current data
                createInitialGrid();
                createEnemyWaveTracker();
                createAttributePlanner();
                createNewGrid();
                // Update the order progress counter
                updateOrderProgressCounter();
            }
        }

        // Create a 6x5 grid (3 rows of cards + 3 rows of dropdowns)
        function createGrid(gridId, gridData, isEditable) {
            const grid = document.getElementById(gridId);
            grid.innerHTML = '';
            
            // Create 6 rows (3 for cards, 3 for dropdowns)
            for (let row = 0; row < 6; row++) {
                for (let col = 0; col < 5; col++) {
                    const index = (row % 2 === 0) ? (Math.floor(row / 2) * 5 + col) : null; // Only rows 0, 2, 4 (1st, 3rd, 5th) have card indices
                    
                    if (row % 2 === 0) {
                        // Card row (rows 0, 2, 4)
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell';
                        if (index !== null) {
                            cell.dataset.index = index;
                            
                            if (isEditable) {
                                cell.onclick = () => openCardModal(index, gridId);
                            }
                            
                            if (gridData[index]) {
                                // Display the assigned card
                                const card = gridData[index];
                                cell.innerHTML = `
                                    <button class="delete-card-btn" onclick="event.stopPropagation(); deleteCard(${index}, '${gridId}')" title="Delete card">×</button>
                                    <div class="grid-card">
                                        <div class="grid-card-image">
                                            ${card.localPath ? `<img src="${card.localPath}" alt="${card.name}">` : 'No Image'}
                                        </div>
                                        <div class="grid-card-name">${card.name}</div>
                                        <div class="grid-card-attribute attribute-${card.attribute.toLowerCase()}">${getAttributeDisplayName(card.attribute)}</div>
                                    </div>
                                `;
                            } else {
                                // Empty cell
                                cell.innerHTML = '<div class="empty-cell">+</div>';
                            }
                        } else {
                            // Empty cell for non-card positions
                            cell.innerHTML = '<div class="empty-cell">+</div>';
                        }
                        grid.appendChild(cell);
                    } else {
                        // Dropdown row (rows 1, 3, 5)
                        const dropdownContainer = document.createElement('div');
                        dropdownContainer.className = 'dropdown-container';
                        
                        if (gridId === 'userCardGrid') {
                            // Number dropdown (1-15) for first column
                            const cardIndex = Math.floor(row / 2) * 5 + col;
                            if (cardIndex < 15) {
                                dropdownContainer.dataset.number = userGridNumbers[cardIndex] || 0;
                                
                                const numberDropdown = document.createElement('select');
                                numberDropdown.className = 'grid-dropdown number-dropdown';
                                numberDropdown.dataset.index = cardIndex;
                                numberDropdown.onchange = (e) => updateGridNumber(cardIndex, e.target.value);
                                
                                // Add options 0-15
                                for (let num = 0; num <= 15; num++) {
                                    const option = document.createElement('option');
                                    option.value = num;
                                    option.textContent = num;
                                    numberDropdown.appendChild(option);
                                }
                                
                                // Set current value if exists, otherwise default to 0
                                if (userGridNumbers[cardIndex] !== undefined) {
                                    numberDropdown.value = userGridNumbers[cardIndex];
                                } else {
                                    numberDropdown.value = 0;
                                }
                                
                                dropdownContainer.appendChild(numberDropdown);
                            }
                        } else {
                            // Attribute dropdown for second column
                            const cardIndex = Math.floor(row / 2) * 5 + col;
                            if (cardIndex < 15) {
                                const attributeDropdown = document.createElement('select');
                                attributeDropdown.className = 'grid-dropdown attribute-dropdown';
                                attributeDropdown.dataset.index = cardIndex;
                                attributeDropdown.onchange = (e) => updateGridAttribute(cardIndex, e.target.value);
                                
                                // Add attribute options
                                const attributes = ['Logic', 'Empathy', 'Intuition'];
                                const attributeDisplayNames = {
                                    'Logic': '🔹 Logic',
                                    'Empathy': '❤️ Empathy',
                                    'Intuition': '🌲 Intuition'
                                };
                                attributes.forEach(attr => {
                                    const option = document.createElement('option');
                                    option.value = attr;
                                    option.textContent = attributeDisplayNames[attr];
                                    attributeDropdown.appendChild(option);
                                });
                                
                                // Set current value if exists
                                if (userGridAttributes[cardIndex]) {
                                    attributeDropdown.value = userGridAttributes[cardIndex];
                                }
                                
                                dropdownContainer.appendChild(attributeDropdown);
                            }
                        }
                        
                        grid.appendChild(dropdownContainer);
                    }
                }
            }
        }

        // ========== Enemy Wave Tracker ==========
        function initializeEnemyWaves() {
            waveCount = 2;
            enemyWaves = buildEmptyEnemyWaves(waveCount);
        }

        function buildEmptyEnemyWaves(count) {
            const waves = [];
            for (let c = 0; c < count; c++) {
                if (c < count - 1) {
                    waves.push(['', '', '']);
                } else {
                    waves.push(['']);
                }
            }
            return waves;
        }

        function createEnemyWaveTracker() {
            const container = document.getElementById('enemyWaveTracker');
            const waveSelect = document.getElementById('waveCountSelect');
            if (!container || !waveSelect) return;

            // Ensure waveCount matches selector
            const selected = parseInt(waveSelect.value, 10);
            if (selected !== waveCount) {
                // Preserve existing selections where possible
                const newWaves = buildEmptyEnemyWaves(selected);
                const minCols = Math.min(enemyWaves.length, newWaves.length);
                for (let c = 0; c < minCols; c++) {
                    const oldCol = enemyWaves[c];
                    const newCol = newWaves[c];
                    const minRows = Math.min(oldCol.length, newCol.length);
                    for (let r = 0; r < minRows; r++) {
                        newCol[r] = oldCol[r] || '';
                    }
                }
                enemyWaves = newWaves;
                waveCount = selected;
            }

            // Render grid
            container.innerHTML = '';
            container.style.setProperty('--wave-columns', waveCount);
            container.style.setProperty('--wave-rows', 3);

            for (let c = 0; c < waveCount; c++) {
                const col = document.createElement('div');
                col.className = 'enemy-wave-column';

                const title = document.createElement('div');
                title.className = 'enemy-wave-title';
                title.textContent = `Wave ${c + 1}`;
                col.appendChild(title);

                const rows = enemyWaves[c];
                const totalRows = c < waveCount - 1 ? 3 : 1;
                for (let r = 0; r < totalRows; r++) {
                    const cell = document.createElement('div');
                    cell.className = 'enemy-wave-cell';

                    const select = document.createElement('select');
                    select.className = 'grid-dropdown attribute-dropdown';
                    select.dataset.col = c;
                    select.dataset.row = r;

                    const attributes = ['', 'Logic', 'Empathy', 'Intuition'];
                    const attributeDisplayNames = {
                        '': 'None',
                        'Logic': '🔹 Logic',
                        'Empathy': '❤️ Empathy',
                        'Intuition': '🌲 Intuition'
                    };
                    attributes.forEach(attr => {
                        const option = document.createElement('option');
                        option.value = attr;
                        option.textContent = attributeDisplayNames[attr];
                        select.appendChild(option);
                    });

                    select.value = rows[r] || '';
                    applyEnemyCellAttributeClass(cell, select.value);
                    select.onchange = (e) => {
                        updateEnemyWaveAttribute(c, r, e.target.value);
                        applyEnemyCellAttributeClass(cell, e.target.value);
                    };

                    cell.appendChild(select);
                    col.appendChild(cell);
                }

                // Fill remaining display rows with placeholders to align height (for 2-row difference)
                if (c < waveCount - 1) {
                    // Already 3 rows rendered
                } else {
                    for (let filler = 0; filler < 2; filler++) {
                        const empty = document.createElement('div');
                        empty.className = 'enemy-wave-cell placeholder';
                        col.appendChild(empty);
                    }
                }

                container.appendChild(col);
            }

            // Bind change event once
            waveSelect.onchange = () => {
                createEnemyWaveTracker();
            };
        }

        function updateEnemyWaveAttribute(colIndex, rowIndex, value) {
            if (!enemyWaves[colIndex]) return;
            enemyWaves[colIndex][rowIndex] = value;
        }

        function applyEnemyCellAttributeClass(cell, attribute) {
            if (!cell) return;
            cell.classList.remove('logic-cell', 'empathy-cell', 'intuition-cell');
            if (attribute === 'Logic') {
                cell.classList.add('logic-cell');
            } else if (attribute === 'Empathy') {
                cell.classList.add('empathy-cell');
            } else if (attribute === 'Intuition') {
                cell.classList.add('intuition-cell');
            }
        }

        // Create the initial card grid with ID selection dropdowns
        function createInitialGrid() {
            const grid = document.getElementById('initialCardGrid');
            grid.innerHTML = '';
            
            // Create 6x5 grid (3 rows of cards + 3 rows of IDs)
            for (let row = 0; row < 6; row++) {
                for (let col = 0; col < 5; col++) {
                    const index = Math.floor(row / 2) * 5 + col; // Only rows 0, 2, 4 have card indices
                    
                    if (row % 2 === 0) {
                        // Card row (rows 0, 2, 4)
                        const cardCell = document.createElement('div');
                        cardCell.className = 'grid-cell';
                        cardCell.dataset.index = index;
                        
                        if (initialGrid[index]) {
                            // Display the assigned card
                            const card = initialGrid[index];
                            
                            // Apply attribute-based coloring based on the card's actual attribute
                            if (card.attribute) {
                                cardCell.classList.add(`${card.attribute.toLowerCase()}-cell`);
                            } else {
                                cardCell.classList.remove('logic-cell', 'empathy-cell', 'intuition-cell');
                            }
                            
                            cardCell.innerHTML = `
                                <button class="delete-card-btn" onclick="event.stopPropagation(); deleteCard(${index}, 'initialCardGrid')" title="Delete card">×</button>
                                <div class="grid-card">
                                    <div class="grid-card-image">
                                        ${card.localPath ? `<img src="${card.localPath}" alt="${card.name}">` : 'No Image'}
                                    </div>
                                    <div class="grid-card-name">${card.name}</div>
                                    <div class="grid-card-attribute attribute-${card.attribute.toLowerCase()}">${getAttributeDisplayName(card.attribute)}</div>
                                </div>
                            `;
                        } else {
                            // Empty cell
                            cardCell.innerHTML = '<div class="empty-cell">+</div>';
                            cardCell.onclick = () => openCardModal(index, 'initialCardGrid');
                        }
                        grid.appendChild(cardCell);
                    } else {
                        // ID row (rows 1, 3, 5)
                        const dropdownContainer = document.createElement('div');
                        dropdownContainer.className = 'dropdown-container';
                        dropdownContainer.dataset.number = userGridNumbers[index] || 0;
                        
                        const numberDropdown = document.createElement('select');
                        numberDropdown.className = 'grid-dropdown number-dropdown';
                        numberDropdown.dataset.index = index;
                        numberDropdown.onchange = (e) => updateGridNumber(index, e.target.value);
                        
                        // Add options 0-15
                        for (let num = 0; num <= 15; num++) {
                            const option = document.createElement('option');
                            option.value = num;
                            option.textContent = num;
                            numberDropdown.appendChild(option);
                        }
                        
                        // Set current value if exists, otherwise default to 0
                        if (userGridNumbers[index] !== undefined) {
                            numberDropdown.value = userGridNumbers[index];
                        } else {
                            numberDropdown.value = 0;
                        }
                        
                        dropdownContainer.appendChild(numberDropdown);
                        grid.appendChild(dropdownContainer);
                    }
                }
            }
        }

        // Create the attribute planner grid (2x15 - attributes row + cards row)
        function createAttributePlanner() {
            const grid = document.getElementById('attributePlanner');
            grid.innerHTML = '';
            
            // Create 2x15 grid (2 rows, 15 columns)
            for (let row = 0; row < 2; row++) {
                for (let col = 0; col < 15; col++) {
                    const index = col; // Column index represents the ID (1-15)
                    
                    if (row === 0) {
                        // Attribute row (row 0)
                        const cell = document.createElement('div');
                        cell.className = 'attribute-planner-cell';
                        
                        // Show the ID number
                        const idLabel = document.createElement('div');
                        idLabel.className = 'id-label';
                        idLabel.textContent = index + 1;
                        cell.appendChild(idLabel);
                        
                        // Attribute dropdown
                        const attributeDropdown = document.createElement('select');
                        attributeDropdown.className = 'grid-dropdown attribute-dropdown';
                        attributeDropdown.dataset.index = index;
                        attributeDropdown.onchange = (e) => updateGridAttribute(index, e.target.value);
                        
                        // Add attribute options with "none" as default
                        const attributes = ['', 'Logic', 'Empathy', 'Intuition'];
                        const attributeDisplayNames = {
                            '': 'None',
                            'Logic': '🔹 Logic',
                            'Empathy': '❤️ Empathy',
                            'Intuition': '🌲 Intuition'
                        };
                        attributes.forEach(attr => {
                            const option = document.createElement('option');
                            option.value = attr;
                            option.textContent = attributeDisplayNames[attr];
                            attributeDropdown.appendChild(option);
                        });
                        
                        // Set current value if exists
                        if (userGridAttributes[index]) {
                            attributeDropdown.value = userGridAttributes[index];
                        } else {
                            attributeDropdown.value = ''; // Default to "none"
                        }
                        
                        // Apply attribute-based coloring to the cell
                        if (userGridAttributes[index]) {
                            cell.classList.add(`${userGridAttributes[index].toLowerCase()}-cell`);
                        } else {
                            // Remove all attribute classes if no attribute is selected
                            cell.classList.remove('logic-cell', 'empathy-cell', 'intuition-cell');
                        }
                        
                        cell.appendChild(attributeDropdown);
                        grid.appendChild(cell);
                    } else {
                        // Card selection row (row 1)
                        const cell = document.createElement('div');
                        cell.className = 'attribute-planner-card-cell';
                        
                        // Find if there's a card assigned to this ID in the new grid
                        const cardIndex = findCardIndexByID(index + 1);
                        let card = null;
                        if (cardIndex !== -1) {
                            card = newGrid[cardIndex];
                        }
                        
                        if (card) {
                            // Apply attribute-based coloring to the card cell in planner
                            if (card.attribute) {
                                cell.classList.add(`${card.attribute.toLowerCase()}-cell`);
                            } else {
                                cell.classList.remove('logic-cell', 'empathy-cell', 'intuition-cell');
                            }
                            // Display the assigned card
                            cell.innerHTML = `
                                <button class="delete-card-btn" onclick="event.stopPropagation(); deleteCardFromAttributePlanner(${index})" title="Delete card">×</button>
                                <div class="attribute-planner-card">
                                    <div class="attribute-planner-card-image">
                                        ${card.localPath ? `<img src="${card.localPath}" alt="${card.name}">` : 'No Image'}
                                    </div>
                                    <div class="attribute-planner-card-name">${card.name}</div>
                                </div>
                            `;
                            cell.onclick = () => openCardModalForAttributePlanner(index);
                        } else {
                            // Remove any previous attribute classes when there's no card
                            cell.classList.remove('logic-cell', 'empathy-cell', 'intuition-cell');
                            // Show placeholder for card selection
                            cell.innerHTML = `
                                <div class="attribute-planner-card-placeholder">
                                    <div class="placeholder-text">Click to select card</div>
                                    <div class="placeholder-icon">+</div>
                                </div>
                            `;
                            cell.onclick = () => openCardModalForAttributePlanner(index);
                        }
                        
                        grid.appendChild(cell);
                    }
                }
            }
        }

        // Helper function to find card index by ID in the new grid
        function findCardIndexByID(targetID) {
            for (let i = 0; i < userGridNumbers.length; i++) {
                if (userGridNumbers[i] === targetID) {
                    return i;
                }
            }
            return -1;
        }

        // Open card modal for attribute planner
        function openCardModalForAttributePlanner(idIndex) {
            // Find the grid position that has this ID
            const gridPosition = findCardIndexByID(idIndex + 1);
            if (gridPosition !== -1) {
                // If there's already a card assigned to this ID, open modal for that position
                openCardModal(gridPosition, 'newCardGrid');
            } else {
                // Find an empty position in the new grid
                let emptyPosition = -1;
                for (let i = 0; i < 15; i++) {
                    if (!newGrid[i] && !userGridNumbers[i]) {
                        emptyPosition = i;
                        break;
                    }
                }
                if (emptyPosition !== -1) {
                    // Assign this ID to the empty position and open modal
                    userGridNumbers[emptyPosition] = idIndex + 1;
                    openCardModal(emptyPosition, 'newCardGrid');
                } else {
                    // No empty position available, show error or find a position to replace
                    alert('You likely accidentally misclicked the order (e.g., there are multiple card with the same order) Please go back to step 1 and check.');
                }
            }
        }

        // Delete card from attribute planner (also removes it from new grid)
        function deleteCardFromAttributePlanner(idIndex) {
            const gridPosition = findCardIndexByID(idIndex + 1);
            if (gridPosition !== -1) {
                deleteCard(gridPosition, 'newCardGrid');
                createAttributePlanner(); // Refresh the attribute planner
            }
        }

        // Create the new card grid showing IDs and attributes
        function createNewGrid() {
            const grid = document.getElementById('newCardGrid');
            grid.innerHTML = '';
            
            // Create 6x5 grid (3 rows of cards + 3 rows of info)
            for (let row = 0; row < 6; row++) {
                for (let col = 0; col < 5; col++) {
                    const index = Math.floor(row / 2) * 5 + col; // Only rows 0, 2, 4 have card indices
                    
                    if (row % 2 === 0) {
                        // Card row (rows 0, 2, 4)
                        const cardCell = document.createElement('div');
                        cardCell.className = 'grid-cell';
                        cardCell.dataset.index = index;
                        
                        // Get the attribute for this position to apply coloring
                        const cardId = userGridNumbers[index];
                        const attribute = cardId !== undefined && cardId >= 1 && cardId <= 15 ? userGridAttributes[cardId - 1] : null;
                        
                        // Apply attribute-based coloring to the card cell
                        if (attribute) {
                            cardCell.classList.add(`${attribute.toLowerCase()}-cell`);
                        } else {
                            // Remove all attribute classes if no attribute is selected
                            cardCell.classList.remove('logic-cell', 'empathy-cell', 'intuition-cell');
                        }
                        
                        if (newGrid[index]) {
                            // Display the assigned card
                            const card = newGrid[index];
                            cardCell.innerHTML = `
                                <button class="delete-card-btn" onclick="event.stopPropagation(); deleteCard(${index}, 'newCardGrid')" title="Delete card">×</button>
                                <div class="grid-card">
                                    <div class="grid-card-image">
                                        ${card.localPath ? `<img src="${card.localPath}" alt="${card.name}">` : 'No Image'}
                                    </div>
                                    <div class="grid-card-name">${card.name}</div>
                                    <div class="grid-card-attribute attribute-${card.attribute.toLowerCase()}">${getAttributeDisplayName(card.attribute)}</div>
                                </div>
                            `;
                        } else {
                            // Empty cell
                            cardCell.innerHTML = '<div class="empty-cell">+</div>';
                            cardCell.onclick = () => openCardModal(index, 'newCardGrid');
                        }
                        grid.appendChild(cardCell);
                    } else {
                        // Info row (rows 1, 3, 5)
                        const infoContainer = document.createElement('div');
                        infoContainer.className = 'info-container';
                        
                        // Show the ID that was selected in initial grid
                        const idDisplay = document.createElement('div');
                        idDisplay.className = 'id-display';
                        idDisplay.textContent = `Order: ${userGridNumbers[index] !== undefined ? userGridNumbers[index] : 'N/A'}`;
                        infoContainer.appendChild(idDisplay);
                        
                        // Show the attribute from attribute planner
                        const attributeDisplay = document.createElement('div');
                        attributeDisplay.className = 'attribute-display';
                        const attribute = userGridNumbers[index] !== undefined && userGridNumbers[index] >= 1 && userGridNumbers[index] <= 15 ? userGridAttributes[userGridNumbers[index] - 1] : null;
                        attributeDisplay.textContent = `Planned Attr: ${getAttributeDisplayName(attribute)}`;
                        attributeDisplay.style.color = '#28a745';
                        infoContainer.appendChild(attributeDisplay);
                        
                        grid.appendChild(infoContainer);
                    }
                }
            }
        }

        // Open the card selection modal
        function openCardModal(cellIndex, gridId) {
            currentGridCell = cellIndex;
            currentGridId = gridId;
            document.getElementById('cardModal').style.display = 'block';
            
            // Update modal title to show which grid is being edited
            const modalTitle = document.getElementById('modalTitle');
            if (gridId === 'initialCardGrid') {
                modalTitle.textContent = `Select a Card for Initial Grid (Position ${cellIndex + 1})`;
            } else if (gridId === 'newCardGrid') {
                modalTitle.textContent = `Select a Card for New Grid (Position ${cellIndex + 1})`;
            }
            
            // Highlight the current grid being edited
            highlightCurrentGrid(gridId);
            
            // Restore previously saved filter values for this grid, or use defaults if none saved
            const savedFilters = modalFilterMemory[gridId] || { attribute: '', search: '' };
            document.getElementById('modalAttributeFilter').value = savedFilters.attribute;
            document.getElementById('modalSearchFilter').value = savedFilters.search;
            
            // Show filter memory indicator if filters were restored
            const filterMemoryIndicator = document.getElementById('filterMemoryIndicator');
            if (savedFilters.attribute || savedFilters.search) {
                filterMemoryIndicator.style.display = 'inline-block';
                // Hide the indicator after 3 seconds
                setTimeout(() => {
                    filterMemoryIndicator.style.display = 'none';
                }, 3000);
            } else {
                filterMemoryIndicator.style.display = 'none';
            }
            
            loadModalCards();
        }

        // Close the modal
        function closeModal() {
            // Save current filter values before closing (in case they were changed but not filtered)
            if (currentGridId) {
                const attributeFilter = document.getElementById('modalAttributeFilter').value;
                const searchFilter = document.getElementById('modalSearchFilter').value;
                modalFilterMemory[currentGridId] = {
                    attribute: attributeFilter,
                    search: searchFilter
                };
            }
            
            // Hide the filter memory indicator
            const filterMemoryIndicator = document.getElementById('filterMemoryIndicator');
            if (filterMemoryIndicator) {
                filterMemoryIndicator.style.display = 'none';
            }
            
            document.getElementById('cardModal').style.display = 'none';
            currentGridCell = null;
            currentGridId = null;
            
            // Remove highlighting from all grids
            const initialGridElement = document.getElementById('initialCardGrid');
            const attributePlannerElement = document.getElementById('attributePlanner');
            const newGridElement = document.getElementById('newCardGrid');
            
            if (initialGridElement) {
                initialGridElement.style.border = '2px solid transparent';
                initialGridElement.style.boxShadow = 'none';
            }
            if (attributePlannerElement) {
                attributePlannerElement.style.border = '2px solid transparent';
                attributePlannerElement.style.boxShadow = 'none';
            }
            if (newGridElement) {
                newGridElement.style.border = '2px solid transparent';
                newGridElement.style.boxShadow = 'none';
            }
        }

        // Load cards in the modal
        function loadModalCards() {
            // In the welcome tab, only show cards from user's loaded collection
            if (currentGridCell !== null && currentGridId !== null) {
                if (userCollection.length === 0) {
                    // No collection loaded, show message
                    const container = document.getElementById('modalCards');
                    container.innerHTML = '<div class="no-cards-message">Please load your card collection first in the "Card Collection" tab.</div>';
                    // Update filter status to show no cards available
                    updateModalFilterStatus('', '', 0, 0);
                    return;
                }
                
                // Apply current filters when opening the modal
                filterModalCards();
            } else {
                // Fallback to all cards (shouldn't happen in normal flow)
                if (allCards.length === 0) {
                    // Try to load from CSV if not already loaded
                    loadAllCards().then(() => {
                        filterModalCards();
                    });
                } else {
                    filterModalCards();
                }
            }
        }

        // Display cards in the modal
        function displayModalCards(cards) {
            const container = document.getElementById('modalCards');
            
            // Only filter out cards that are already in the current grid being edited
            let availableCards = cards;
            if (currentGridId === 'initialCardGrid') {
                availableCards = cards.filter(card => {
                    return !initialGrid.some(gridCard => gridCard && gridCard.name === card.name);
                });
            } else if (currentGridId === 'newCardGrid') {
                availableCards = cards.filter(card => {
                    return !newGrid.some(gridCard => gridCard && gridCard.name === card.name);
                });
            }
            
            if (availableCards.length === 0) {
                const gridName = currentGridId === 'initialCardGrid' ? 'Initial Grid' : 'New Grid';
                container.innerHTML = `<div class="no-cards-message">No available cards. All cards are already in the ${gridName}.</div>`;
                return;
            }

            // Sort by rarity then by name
            const sortedCards = availableCards.sort((a, b) => {
                const rarityOrder = { 'SSS icon': 1, 'SSR icon': 2, 'SR icon': 3, 'R icon': 4, 'N icon': 5 };
                const aRarity = rarityOrder[a.rarity] || 6;
                const bRarity = rarityOrder[b.rarity] || 6;
                
                if (aRarity !== bRarity) {
                    return aRarity - bRarity;
                }
                return a.name.localeCompare(b.name);
            });

            container.innerHTML = sortedCards.map(card => `
                <div class="modal-card-item" onclick="selectCardForGrid('${card.name}')">
                    <div class="rarity-badge">${card.rarity.replace(' icon', '')}</div>
                    <div class="modal-card-image">
                        ${card.localPath ? `<img src="${card.localPath}" alt="${card.name}">` : 'No Image'}
                    </div>
                    <div class="modal-card-name">${card.name}</div>
                    <div class="modal-card-attribute attribute-${card.attribute.toLowerCase()}">${getAttributeDisplayName(card.attribute)}</div>
                </div>
            `).join('');
        }

        // Filter cards in the modal
        function filterModalCards() {
            const attributeFilter = document.getElementById('modalAttributeFilter').value;
            const searchFilter = document.getElementById('modalSearchFilter').value.toLowerCase();
            
            // Save the current filter values for the current grid to remember them
            if (currentGridId) {
                modalFilterMemory[currentGridId] = {
                    attribute: attributeFilter,
                    search: document.getElementById('modalSearchFilter').value // Save the original value, not lowercase
                };
            }
            
            // Use userCollection instead of allCards for filtering in the welcome tab
            const cardsToFilter = currentGridCell !== null ? userCollection : allCards;
            
            console.log('Filtering modal cards:', {
                attributeFilter,
                searchFilter,
                totalCards: cardsToFilter.length,
                currentGridCell,
                currentGridId
            });
            
            const filtered = cardsToFilter.filter(card => {
                const matchesAttribute = !attributeFilter || card.attribute === attributeFilter;
                const matchesSearch = !searchFilter || card.name.toLowerCase().includes(searchFilter);
                
                // Only check if card is already in the current grid being edited
                let notInCurrentGrid = true;
                if (currentGridId === 'initialCardGrid') {
                    notInCurrentGrid = !initialGrid.some(gridCard => gridCard && gridCard.name === card.name);
                } else if (currentGridId === 'newCardGrid') {
                    notInCurrentGrid = !newGrid.some(gridCard => gridCard && gridCard.name === card.name);
                }
                return matchesAttribute && matchesSearch && notInCurrentGrid;
            });
            
            // Update filter status display
            updateModalFilterStatus(attributeFilter, searchFilter, filtered.length, cardsToFilter.length);
            
            displayModalCards(filtered);
        }

        // Select a card for the grid
        function selectCardForGrid(cardName) {
            // Find card from user's collection first, then fallback to all cards
            let card = userCollection.find(c => c.name === cardName);
            if (!card) {
                card = allCards.find(c => c.name === cardName);
            }
            
            if (card && currentGridCell !== null && currentGridId !== null) {
                // Add card to the appropriate grid
                if (currentGridId === 'initialCardGrid') {
                    initialGrid[currentGridCell] = card;

                    createInitialGrid();
                } else if (currentGridId === 'newCardGrid') {
                    newGrid[currentGridCell] = card;
                    createNewGrid();
                    createAttributePlanner(); // Refresh attribute planner to show the new card
                }
                closeModal();
            }
        }

        // Update number value for grid cell
        function updateGridNumber(index, value) {
            userGridNumbers[index] = parseInt(value);
            // Update the order progress counter
            updateOrderProgressCounter();
            // Refresh both grids to show updated ID and attribute info
            createInitialGrid();
            createNewGrid();
            createAttributePlanner(); // Refresh attribute planner to show updated card assignments
        }

        // Update attribute value for grid cell
        function updateGridAttribute(index, value) {
            userGridAttributes[index] = value;
            // Refresh both grids to show updated attribute info and coloring
            createAttributePlanner();
            createNewGrid();
        }

        // Update the order progress counter based on how many cards have order numbers assigned
        function updateOrderProgressCounter() {
            const counterElement = document.getElementById('orderProgressCounter');
            const warningElement = document.getElementById('orderWarning');
            
            if (counterElement) {
                let assignedCount = 0;
                for (let i = 0; i < 15; i++) {
                    if (userGridNumbers[i] && userGridNumbers[i] > 0) {
                        assignedCount++;
                    }
                }
                counterElement.textContent = assignedCount;
                
                // Update color based on progress
                if (assignedCount === 15) {
                    counterElement.style.color = '#28a745'; // Green when complete
                    // Check for duplicate orders when all 15 are assigned
                    checkForDuplicateOrders();
                } else if (assignedCount >= 10) {
                    counterElement.style.color = '#ffc107'; // Yellow when close
                    // Hide warning when not all cards are assigned
                    if (warningElement) {
                        warningElement.style.display = 'none';
                    }
                } else {
                    counterElement.style.color = '#dc3545'; // Red when few assigned
                    // Hide warning when not all cards are assigned
                    if (warningElement) {
                        warningElement.style.display = 'none';
                    }
                }
            }
        }

        // Check for duplicate orders and display warnings
        function checkForDuplicateOrders() {
            const warningElement = document.getElementById('orderWarning');
            if (!warningElement) return;
            
            // Create a map to track which orders appear at which positions
            const orderMap = new Map();
            const duplicates = [];
            
            // Check each grid position for assigned orders
            for (let i = 0; i < 15; i++) {
                const order = userGridNumbers[i];
                if (order && order > 0) {
                    if (orderMap.has(order)) {
                        // Found a duplicate order
                        const existingPositions = orderMap.get(order);
                        existingPositions.push(i);
                        duplicates.push({
                            order: order,
                            positions: existingPositions
                        });
                    } else {
                        // First time seeing this order
                        orderMap.set(order, [i]);
                    }
                }
            }
            
            // Filter out single occurrences and format warning message
            const actualDuplicates = duplicates.filter(dup => dup.positions.length > 1);
            
            if (actualDuplicates.length > 0) {
                // Build warning message
                let warningText = '<strong>⚠️ Warning: Duplicate orders detected!</strong><br>';
                warningText += 'The following cards have the same order number:<br>';
                
                actualDuplicates.forEach(dup => {
                    warningText += `<br><strong>Order ${dup.order}:</strong> `;
                    const positionTexts = dup.positions.map(pos => {
                        const row = Math.floor(pos / 5) + 1;
                        const col = (pos % 5) + 1;
                        return `Row ${row}, Column ${col}`;
                    });
                    warningText += positionTexts.join(', ');
                });
                
                warningElement.innerHTML = warningText;
                warningElement.style.display = 'block';
            } else {
                // No duplicates found, hide warning
                warningElement.style.display = 'none';
            }
        }

        // Delete card from grid cell
        function deleteCard(index, gridType) {
            if (gridType === 'initialCardGrid') {
                initialGrid[index] = null;
                createInitialGrid();
            } else if (gridType === 'newCardGrid') {
                newGrid[index] = null;
                createNewGrid();
                createAttributePlanner(); // Refresh attribute planner to remove the card
            }
        }

        // Highlight the current grid being edited
        function highlightCurrentGrid(gridId) {
            // Remove highlight from all grids
            const initialGridElement = document.getElementById('initialCardGrid');
            const attributePlannerElement = document.getElementById('attributePlanner');
            const newGridElement = document.getElementById('newCardGrid');
            
            if (initialGridElement) {
                initialGridElement.style.border = '2px solid transparent';
                initialGridElement.style.boxShadow = 'none';
            }
            if (attributePlannerElement) {
                attributePlannerElement.style.border = '2px solid transparent';
                attributePlannerElement.style.boxShadow = 'none';
            }
            if (newGridElement) {
                newGridElement.style.border = '2px solid transparent';
                newGridElement.style.boxShadow = 'none';
            }
            
            // Highlight the current grid
            if (gridId === 'initialCardGrid' && initialGridElement) {
                initialGridElement.style.border = '2px solid #667eea';
                initialGridElement.style.boxShadow = '0 0 10px rgba(102, 126, 234, 0.3)';
            } else if (gridId === 'newCardGrid' && newGridElement) {
                newGridElement.style.border = '2px solid #007bff';
                newGridElement.style.boxShadow = '0 0 10px rgba(0, 123, 255, 0.3)';
            }
        }

        // Update modal filter status display
        function updateModalFilterStatus(attributeFilter, searchFilter, filteredCount, totalCount) {
            const statusText = document.getElementById('filterStatusText');
            const filterStatus = document.getElementById('modalFilterStatus');
            
            const gridName = currentGridId === 'initialCardGrid' ? 'Initial Grid' : 'New Grid';
            
            let statusMessage = '';
            let statusColor = '#f8f9fa';
            let textColor = '#666';
            
            if (attributeFilter && searchFilter) {
                statusMessage = `Showing ${filteredCount} of ${totalCount} cards for ${gridName} (filtered by "${attributeFilter}" attribute and "${searchFilter}" search)`;
                statusColor = '#e3f2fd';
                textColor = '#1976d2';
            } else if (attributeFilter) {
                statusMessage = `Showing ${filteredCount} of ${totalCount} cards for ${gridName} (filtered by "${attributeFilter}" attribute)`;
                statusColor = '#e8f5e8';
                textColor = '#2e7d32';
            } else if (searchFilter) {
                statusMessage = `Showing ${filteredCount} of ${totalCount} cards for ${gridName} (filtered by "${searchFilter}" search)`;
                statusColor = '#fff3e0';
                textColor = '#f57c00';
            } else {
                statusMessage = `Showing ${filteredCount} of ${totalCount} available cards for ${gridName}`;
                statusColor = '#f8f9fa';
                textColor = '#666';
            }
            
            statusText.textContent = statusMessage;
            filterStatus.style.backgroundColor = statusColor;
            filterStatus.style.color = textColor;
        }

        // Export grid configuration
        function exportGridConfig() {
            const gridConfig = {
                initialGrid: initialGrid,
                newGrid: newGrid,
                numbers: userGridNumbers,
                attributes: userGridAttributes,
                waveCount: waveCount,
                enemyWaves: enemyWaves,
                modalFilterMemory: modalFilterMemory, // Include filter memory in export
                timestamp: new Date().toISOString()
            };
            
            const dataStr = JSON.stringify(gridConfig, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = 'grid_configuration.json';
            link.click();
        }

        // Clear filter memory
        function clearFilterMemory() {
            if (confirm('Are you sure you want to clear all saved filter preferences? This will reset attribute and search filters to default values when you next open the modal.')) {
                modalFilterMemory = {};
                alert('Filter memory cleared successfully!');
            }
        }
        
        // Load grid configuration
        function loadGridConfig() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const config = JSON.parse(e.target.result);
                            if (config.initialGrid && config.newGrid && config.numbers && config.attributes) {
                                initialGrid = config.initialGrid;
                                newGrid = config.newGrid;
                                userGridNumbers = config.numbers;
                                userGridAttributes = config.attributes;
                                if (typeof config.waveCount === 'number' && Array.isArray(config.enemyWaves)) {
                                    waveCount = config.waveCount;
                                    enemyWaves = config.enemyWaves;
                                } else {
                                    // Backfill if missing
                                    waveCount = 2;
                                    enemyWaves = buildEmptyEnemyWaves(waveCount);
                                }
                                // Restore filter memory if available
                                if (config.modalFilterMemory) {
                                    modalFilterMemory = config.modalFilterMemory;
                                }
                                createInitialGrid();
                                // Sync wave selector then render
                                const waveSelect = document.getElementById('waveCountSelect');
                                if (waveSelect) {
                                    waveSelect.value = String(waveCount);
                                }
                                createEnemyWaveTracker();
                                createAttributePlanner();
                                createNewGrid();
                                // Update the order progress counter after loading
                                updateOrderProgressCounter();
                                gridsInitialized = true;
                                // alert('Grid configuration loaded successfully!');
                            } else if (config.cards && config.numbers && config.attributes) {
                                // Handle old format for backward compatibility
                                initialGrid = config.cards;
                                userGridNumbers = config.numbers;
                                userGridAttributes = config.attributes;
                                // Restore filter memory if available (even in legacy format)
                                if (config.modalFilterMemory) {
                                    modalFilterMemory = config.modalFilterMemory;
                                }
                                // Initialize wave data for legacy files
                                waveCount = 2;
                                enemyWaves = buildEmptyEnemyWaves(waveCount);
                                createInitialGrid();
                                const waveSelect = document.getElementById('waveCountSelect');
                                if (waveSelect) {
                                    waveSelect.value = String(waveCount);
                                }
                                createEnemyWaveTracker();
                                createAttributePlanner();
                                createNewGrid();
                                // Update the order progress counter after loading
                                updateOrderProgressCounter();
                                gridsInitialized = true;
                                // alert('Grid configuration loaded successfully! (Legacy format)');
                            } else {
                                alert('Invalid grid configuration file.');
                            }
                        } catch (error) {
                            alert('Error reading configuration file.');
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const cardModal = document.getElementById('cardModal');
            const collectionPreviewModal = document.getElementById('collectionPreviewModal');
            
            if (event.target === cardModal) {
                closeModal();
            }
            
            if (event.target === collectionPreviewModal) {
                closeCollectionPreviewModal();
            }
        }

        // Load all cards from CSV
        async function loadAllCards() {
            try {
                const response = await fetch('data/tot_cards_with_icons.csv');
                const csvText = await response.text();
                const lines = csvText.split('\n');
                const headers = lines[0].split(',');
                
                allCards = [];
                for (let i = 1; i < lines.length; i++) {
                    if (lines[i].trim()) {
                        const values = lines[i].split(',');
                        const card = {
                            name: values[0],
                            character: values[1],
                            rarity: values[2],
                            attribute: values[3],
                            iconUrl: values[4],
                            localPath: values[5]
                        };
                        allCards.push(card);
                    }
                }
                
                displayCreateCards(allCards);
            } catch (error) {
                console.error('Error loading cards:', error);
                document.getElementById('createCards').innerHTML = '<div class="no-cards-message">Error loading cards. Please check if the CSV file  sts.</div>';
            }
        }

        // Display cards in create tab
        function displayCreateCards(cards) {
            const container = document.getElementById('createCards');
            if (cards.length === 0) {
                container.innerHTML = '<div class="no-cards-message">No cards found matching your criteria.</div>';
                return;
            }

            // Sort by rarity then by name
            const sortedCards = cards.sort((a, b) => {
                const rarityOrder = { 'SSS icon': 1, 'SSR icon': 2, 'SR icon': 3, 'R icon': 4, 'N icon': 5 };
                const aRarity = rarityOrder[a.rarity] || 6;
                const bRarity = rarityOrder[b.rarity] || 6;
                
                if (aRarity !== bRarity) {
                    return aRarity - bRarity;
                }
                return a.name.localeCompare(b.name);
            });

            container.innerHTML = sortedCards.map(card => `
                <div class="card-item">
                    <div class="rarity-badge">${card.rarity.replace(' icon', '')}</div>
                    <div class="card-image">
                        ${card.localPath ? `<img src="${card.localPath}" alt="${card.name}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 8px;">` : 'No Image'}
                    </div>
                    <div class="card-name">${card.name}</div>
                    <div class="card-attribute attribute-${card.attribute.toLowerCase()}">${getAttributeDisplayName(card.attribute)}</div>
                    <button class="add-card-btn" onclick="addCardToCollection('${card.name}')" title="Add to collection">+</button>
                </div>
            `).join('');
        }

        // Filter cards in create tab
        function filterCreateCards() {
            const attributeFilter = document.getElementById('createAttributeFilter').value;
            const searchFilter = document.getElementById('createSearchFilter').value.toLowerCase();
            
            const filtered = allCards.filter(card => {
                const matchesAttribute = !attributeFilter || card.attribute === attributeFilter;
                const matchesSearch = !searchFilter || card.name.toLowerCase().includes(searchFilter);
                return matchesAttribute && matchesSearch;
            });
            
            displayCreateCards(filtered);
        }

        // Add card to collection
        function addCardToCollection(cardName) {
            const card = allCards.find(c => c.name === cardName);
            if (card && !selectedCards.find(c => c.name === cardName)) {
                selectedCards.push(card);
                displaySelectedCards();
            }
        }

        // Remove card from collection
        function removeCardFromCollection(cardName) {
            selectedCards = selectedCards.filter(c => c.name !== cardName);
            displaySelectedCards();
        }

        // Display selected cards
        function displaySelectedCards() {
            const container = document.getElementById('selectedCards');
            if (selectedCards.length === 0) {
                container.innerHTML = '<div class="no-cards-message">No cards selected yet. Click the + button on cards to add them to your collection.</div>';
                return;
            }

            // Sort by rarity then by name
            const sortedCards = selectedCards.sort((a, b) => {
                const rarityOrder = { 'SSS icon': 1, 'SSR icon': 2, 'SR icon': 3, 'R icon': 4, 'N icon': 5 };
                const aRarity = rarityOrder[a.rarity] || 6;
                const bRarity = rarityOrder[b.rarity] || 6;
                
                if (aRarity !== bRarity) {
                    return aRarity - bRarity;
                }
                return a.name.localeCompare(b.name);
            });

            container.innerHTML = sortedCards.map(card => `
                <div class="card-item">
                    <div class="rarity-badge">${card.rarity.replace(' icon', '')}</div>
                    <div class="card-image">
                        ${card.localPath ? `<img src="${card.localPath}" alt="${card.name}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 8px;">` : 'No Image'}
                    </div>
                    <div class="card-name">${card.name}</div>
                    <div class="card-attribute attribute-${card.attribute.toLowerCase()}">${getAttributeDisplayName(card.attribute)}</div>
                    <button class="add-card-btn" onclick="removeCardFromCollection('${card.name}')" title="Remove from collection" style="background: #dc3545;">-</button>
                </div>
            `).join('');
        }

        // Load user collection
        function loadCollection() {
            const fileInput = document.getElementById('collectionFile');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('Please select a file first.');
                return;
            }

            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const content = e.target.result;
                    
                    // Try to parse as JSON first
                    if (file.name.endsWith('.json')) {
                        userCollection = JSON.parse(content);
                    } else if (file.name.endsWith('.txt')) {
                        // Ensure allCards is loaded first
                        if (allCards.length === 0) {
                            console.log('Loading all cards first...');
                            await loadAllCards();
                        }
                        
                        // Parse text file - each line is a card name
                        const cardNames = content.split('\n').filter(line => line.trim() !== '');
                        console.log('Loading text file with card names:', cardNames);
                        console.log('Available cards in database:', allCards.length);
                        
                        // Find matching cards from the database with more flexible matching
                        userCollection = cardNames.map(cardName => {
                            const trimmedName = cardName.trim();
                            
                            // Try exact match first
                            let card = allCards.find(c => c.name === trimmedName);
                            
                            // If no exact match, try case-insensitive match
                            if (!card) {
                                card = allCards.find(c => c.name.toLowerCase() === trimmedName.toLowerCase());
                            }
                            
                            // If still no match, try partial match
                            if (!card) {
                                card = allCards.find(c => c.name.toLowerCase().includes(trimmedName.toLowerCase()) || 
                                                       trimmedName.toLowerCase().includes(c.name.toLowerCase()));
                            }
                            
                            if (card) {
                                console.log(`Found card: ${card.name} (${card.rarity}, ${card.attribute})`);
                                return card;
                            } else {
                                // If card not found, create a placeholder with just the name
                                console.warn(`Card not found: ${trimmedName}`);
                                return {
                                    name: trimmedName,
                                    rarity: 'Unknown',
                                    attribute: 'Unknown',
                                    localPath: null
                                };
                            }
                        });
                        
                        console.log('Final collection loaded:', userCollection);
                    } else {
                        throw new Error('Unsupported file type');
                    }
                    
                    filterCards();
                    updateCollectionStatus();
                    // Sync Create/Edit selected cards with the loaded collection
                    selectedCards = Array.isArray(userCollection) ? [...userCollection] : [];
                    displaySelectedCards();
                } catch (error) {
                    if (file.name.endsWith('.txt')) {
                        alert('Error reading text file. Please make sure it\'s a valid text file with one card name per line.');
                    } else {
                        alert('Error reading file. Please make sure it\'s a valid JSON file.');
                    }
                }
            };
            reader.readAsText(file);
        }

        // Filter cards in collection tab
        function filterCards() {
            const attributeFilterElement = document.getElementById('attributeFilter');
            const attributeFilter = attributeFilterElement.value;
            const searchFilter = document.getElementById('searchFilter').value.toLowerCase();
            
            const filtered = userCollection.filter(card => {
                const matchesAttribute = !attributeFilter || card.attribute === attributeFilter;
                const matchesSearch = !searchFilter || card.name.toLowerCase().includes(searchFilter);
                return matchesAttribute && matchesSearch;
            });
            
            displayCollectionCards(filtered);
        }

        // Display collection cards
        function displayCollectionCards(cards) {
            const container = document.getElementById('collectionCards');
            if (cards.length === 0) {
                container.innerHTML = '<div class="no-cards-message">No cards found matching your criteria.</div>';
                return;
            }

            // Sort by rarity then by name
            const sortedCards = cards.sort((a, b) => {
                const rarityOrder = { 'SSS icon': 1, 'SSR icon': 2, 'SR icon': 3, 'R icon': 4, 'N icon': 5 };
                const aRarity = rarityOrder[a.rarity] || 6;
                const bRarity = rarityOrder[b.rarity] || 6;
                
                if (aRarity !== bRarity) {
                    return aRarity - bRarity;
                }
                return a.name.localeCompare(b.name);
            });

            container.innerHTML = sortedCards.map(card => `
                <div class="card-item">
                    <div class="rarity-badge">${card.rarity.replace(' icon', '')}</div>
                    <div class="card-image">
                        ${card.localPath ? `<img src="${card.localPath}" alt="${card.name}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 8px;">` : 'No Image'}
                    </div>
                    <div class="card-name">${card.name}</div>
                    <div class="card-attribute attribute-${card.attribute.toLowerCase()}">${getAttributeDisplayName(card.attribute)}</div>
                </div>
            `).join('');
        }

        // Update collection status display
        function updateCollectionStatus() {
            const statusText = document.getElementById('statusText');
            const collectionStatus = document.getElementById('collectionStatus');
            
            if (userCollection.length > 0) {
                statusText.textContent = `${userCollection.length} cards loaded`;
                collectionStatus.style.backgroundColor = '#d4edda';
                collectionStatus.style.borderColor = '#c3e6cb';
                collectionStatus.style.color = '#155724';
            } else {
                statusText.textContent = 'No collection loaded';
                collectionStatus.style.backgroundColor = '#f8f9fa';
                collectionStatus.style.borderColor = '#dee2e6';
                collectionStatus.style.color = '#6c757d';
            }
        }

        // Download collection
        function downloadCollection() {
            if (selectedCards.length === 0) {
                alert('Please select at least one card before creating a collection.');
                return;
            }

            // Show preview modal instead of downloading directly
            showCollectionPreviewModal();
        }

        // Show collection preview modal
        function showCollectionPreviewModal() {
            const modal = document.getElementById('collectionPreviewModal');
            const previewContent = document.getElementById('collectionPreviewContent');
            
            // Update the card count in the header
            const previewHeader = modal.querySelector('.preview-header strong');
            previewHeader.textContent = `Selected Cards (${selectedCards.length}):`;
            
            // Create preview content
            const previewText = selectedCards.map(card => card.name).join('\n');
            previewContent.innerHTML = `<pre style="background: #f8f9fa; padding: 15px; border-radius: 5px; white-space: pre-wrap; font-family: monospace; max-height: 300px; overflow-y: auto;">${previewText}</pre>`;
            
            // Show the modal
            modal.style.display = 'block';
            
            // Store the download type for the confirm function
            modal.dataset.downloadType = 'simple';
        }

        // Close collection preview modal
        function closeCollectionPreviewModal() {
            document.getElementById('collectionPreviewModal').style.display = 'none';
        }

        // Confirm download after preview
        function confirmDownload() {
            const modal = document.getElementById('collectionPreviewModal');
            const downloadType = modal.dataset.downloadType || 'simple';
            
            let textContent, fileName;
            
            if (downloadType === 'detailed') {
                // Sort by rarity then by name
                const sortedCards = selectedCards.sort((a, b) => {
                    const rarityOrder = { 'SSS icon': 1, 'SSR icon': 2, 'SR icon': 3, 'R icon': 4, 'N icon': 5 };
                    const aRarity = rarityOrder[a.rarity] || 6;
                    const bRarity = rarityOrder[b.rarity] || 6;
                    
                    if (aRarity !== bRarity) {
                        return aRarity - bRarity;
                    }
                    return a.name.localeCompare(b.name);
                });

                // Create detailed text representation
                textContent = sortedCards.map(card => 
                    `${card.name} (${card.rarity.replace(' icon', '')} - ${getAttributeDisplayName(card.attribute)})`
                ).join('\n');
                fileName = 'card_collection_detailed.txt';
            } else {
                // Create simple text representation
                textContent = selectedCards.map(card => card.name).join('\n');
                fileName = 'card_collection.txt';
            }
            
            const dataBlob = new Blob([textContent], { type: 'text/plain' });
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = fileName;
            link.click();
            
            // Close the modal after download
            closeCollectionPreviewModal();
        }

        // Show detailed collection preview modal
        function showDetailedCollectionPreviewModal() {
            const modal = document.getElementById('collectionPreviewModal');
            const previewContent = document.getElementById('collectionPreviewContent');
            
            // Update the card count in the header
            const previewHeader = modal.querySelector('.preview-header strong');
            previewHeader.textContent = `Selected Cards (${selectedCards.length}) - Detailed View:`;
            
            // Sort by rarity then by name
            const sortedCards = selectedCards.sort((a, b) => {
                const rarityOrder = { 'SSS icon': 1, 'SSR icon': 2, 'SR icon': 3, 'R icon': 4, 'N icon': 5 };
                const aRarity = rarityOrder[a.rarity] || 6;
                const bRarity = rarityOrder[b.rarity] || 6;
                
                if (aRarity !== bRarity) {
                    return aRarity - bRarity;
                }
                return a.name.localeCompare(b.name);
            });

            // Create detailed preview content
            const detailedText = sortedCards.map(card => 
                `${card.name} (${card.rarity.replace(' icon', '')} - ${getAttributeDisplayName(card.attribute)})`
            ).join('\n');
            
            previewContent.innerHTML = `<pre style="background: #f8f9fa; padding: 15px; border-radius: 5px; white-space: pre-wrap; font-family: monospace; max-height: 300px; overflow-y: auto;">${detailedText}</pre>`;
            
            // Show the modal
            modal.style.display = 'block';
            
            // Store the download type for the confirm function
            modal.dataset.downloadType = 'detailed';
        }

        // Debug function to see what's in the card database
        function debugCardDatabase() {
            console.log('=== CARD DATABASE DEBUG ===');
            console.log('Total cards in database:', allCards.length);
            if (allCards.length > 0) {
                console.log('Sample cards:');
                allCards.slice(0, 5).forEach((card, index) => {
                    console.log(`${index + 1}. ${card.name} - ${card.rarity} - ${card.attribute} - ${card.localPath ? 'Has Image' : 'No Image'}`);
                });
                
                // Check for cards with specific names
                const testNames = ['Blossom Encounters', 'blossom encounters', 'Blossom'];
                testNames.forEach(testName => {
                    const found = allCards.find(c => c.name === testName);
                    console.log(`Searching for "${testName}":`, found ? 'FOUND' : 'NOT FOUND');
                    if (found) {
                        console.log('  Details:', found);
                    }
                });
            } else {
                console.log('No cards loaded yet. Try loading the create tab first.');
            }
            console.log('========================');
        }

        // Download collection as detailed text (name + rarity + attribute)
        function downloadDetailedCollection() {
            if (selectedCards.length === 0) {
                alert('Please select at least one card before creating a collection.');
                return;
            }

            // Show preview modal with detailed information
            showDetailedCollectionPreviewModal();
        }
    </script>
</body>
</html>
